# Redis

## 1、简介

基于内存读写性能，读110000/s、写80000/s左右，也可将内存中的数据持久化到磁盘中，实现容错机制；并且支持集群、哨兵等高可用、高性能分布式缓存策略；有五种数据类型进行实现不同的业务逻辑，

## 2、redis有什么缺点？

- 缓存与数据库双写一致性问题

- 缓存雪崩问题

- 缓存穿透问题

- 缓存并发竞争问题

## 3、线程io模型

### 3.1、为什么不采用多线程或多进程处理？

- 多线程处理可能涉及到锁 

- 多线程处理会涉及到线程切换而消耗CPU

### 3.2、单线程处理的缺点？

> 无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善

## 4、事务

redis并不支持“原子性”，只是满足了事务“隔离性”中的串行化——当前事务中，有着不被其它事务打断的权利

（如果redis的事务multi开始之后，更新其中的一个key，如果这个key在别的事务中已被修改，当前事务执行之后，会覆盖之前的操作）

即使某个命令执行失败，事务队列中的所有其他命令仍然会执行；Redis不会停止执行事务中的命令

<font color="#FF0000">**出现语法错误时，会将事务进行丢弃**</font>

### 4.1、为什么redis不支持回滚？

比较中肯的回答是为了redis的简单快速性，网上大部分说的就是像redis中的错误语法，在生产中是不常见的，而是应该在程序开发以及测试期间就解决的。所以redis不支持回滚

## 5、redis的过期策略以及内存淘汰机制

### 5.1、问题描述

比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?

### 5.2、redis过期策略

1. 定时删除
2. 定期删除
3. 惰性删除

### 5.3、回答

redis采用的是定期删除+惰性删除策略

### 5.4、为什么不用定时删除策略呢？

定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略

### 5.5、定期删除+惰性删除是如何工作的呢

定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除
于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除

### 5.6、采用定期删除+惰性删除就没其他问题了么?

如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用**内存淘汰机制**

在redis.conf中有一行配置

```shell
# 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。推荐使用，目前项目在用这种
# maxmemory-policy allkeys-lru
```

## 6、缓存穿透

### 6.1、简介

用户请求缓存中不存在的数据，导致所有请求会进行访问DB，如果进行恶意特别多次访问，可能会导致数据库层面挂掉

### 6.2、解决方案

- 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试
- 采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做**缓存预热**(项目启动前，先加载缓存)操作
- 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回
- 也可以采用一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟
  -  第一，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间 ( 如果是攻击，问题更严重 )，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除
  - 第二，缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为 5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象

## 7、缓存雪崩

### 7.1、简介

如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩

### 7.2、解决方案

#### 7.2.1、加锁排队

在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待

业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如[Redis](http://lib.csdn.net/base/redis)的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法

SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果

#### 7.2.2、二级缓存、双缓存策略

 A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期

- I 从缓存A读数据库，有则直接返回
- II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程
- III 更新线程同时更新缓存A和缓存B

#### 7.2.3、缓存永远不过期

- 从缓存上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期
- 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期
- 唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据（一般可以接受）

## 8、缓存预热

可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀

## 9、缓存与DB的一致性



## 10、如何解决redis的并发竞争key问题

### 10.1、分析

同时有多个子系统去set一个key，生产环境基本都是redis集群环境，做了数据分片操作；事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上；所以，对于<font color="#FF0000">集群式环境不推荐使用redis事务机制</font>

### 10.2、解决方案

#### 10.2.1、分布式锁+时间戳

**整体技术方案**

这种情况，主要是准备一个分布式锁，大家去抢锁，抢到锁就做set操作

加锁的目的实际上就是把并行读写改成串行读写的方式，从而来避免资源竞争

**redis分布式锁的实现**

网上一般使用redis函数是setnx()来进行分布式锁实现，以及获取锁之后再设置过期时间等等。。但是这种方式有一个缺陷，那就是在获取到锁，但还没有进行expire()进行设置过期时间之前，程序出现问题，就会造成死锁情况

推荐使用一个原子性的组合操作

```java
// 自行网上百度用法
String result = shardedJedis
                    .set(key.getBytes(), obj, "nx".getBytes(), "ex".getBytes(), timeout);
```

根据result的返回值判断是否获取到了锁，不为空证明获取到了锁，反之则没获取到锁

**时间戳**

要求key顺序执行时，需要保存一个时间戳判断set顺序

```java
系统A key 1 {ValueA 7:00}

系统B key 1 { ValueB 7:05}
```

假设系统B先抢到锁，将key1设置为{ ValueB 7:05}；接下来系统A抢到锁，发现key1的时间戳早于缓存中的时间戳（7:00<7:05）那么就不进行set操作

**其余分布式锁实现方式**

也可使用zookeeper等中间件来做分布式锁

#### 10.2.2、消息队列

在并发量过大的情况下,可以通过消息中间件进行处理,把并行读写进行串行化

把Redis.set操作放在队列中使其串行化,必须的一个一个执行

这种方式在一些高并发的场景中算是一种通用的解决方案

（这种方式需要考虑消息队列对与消息的发送顺序、）

## 参考网址

https://www.cnblogs.com/rjzheng/p/9096228.html

https://blog.csdn.net/liupeng_qwert/article/details/77263187

https://blog.csdn.net/lby0307/article/details/79680326

https://blog.csdn.net/ChenRui_yz/article/details/85096418